@[toc] 

# 电脑的本质
![在这里插入图片描述](https://img-blog.csdnimg.cn/02abb81086014b758dc21e4925343a38.png)
- 这里的每个中括号代表它的地址，**address**
- 每个地址上都存有一定的东西，**value**，每个地址上都有内容




<u>其中类似‘[2]’，这样的，我们称之为地址address</u>

## 读写操作
我们的计算机一般就两个操作**R，W**

R
>R（address，mm<内存>）：在内存中找某个位置

W
>W(address,mm<内存>,'*'):在内存中在address位置写入<u>&</u>

读取
R([100],mm)='鸟'
>从内存的指定位置中读到了别人已经写入的数据

写入
W([64],mm,'shen')
>在内存中地址位64处，写入shen

所以电脑本质就是帮助我们进行读写操作的

# bit
## 电脑电的由来
<u>电脑之所以叫电脑，是因为它的**内存**中存放的就是**电压**</u>
而不是，上述写的'鸟'，‘*’，这类东西

我们知道电压有高有低
我们规定高电压=1，低电压=0


![在这里插入图片描述](https://img-blog.csdnimg.cn/d135aa0e9951453ca1e353d814605834.png
因为有了上述规定，这个<==> 10101
这样就把电压抽象成了数字

同样
![在这里插入图片描述](https://img-blog.csdnimg.cn/e6460902c0ae430781b55fb47aa17ba9.png)
这样也把电压抽象成了数字

由于内存中都是这些电压，所以内存中只有<u>0/1</u>


## 内存

![在这里插入图片描述](https://img-blog.csdnimg.cn/3745d87cd4fb47088b38f1720d5d326e.png)

内存中存储的全是0/1
但是由于这些0，1特别多，不好找，所以我们把这些0/1进行分块，
（每4个一块，或者每3个一块）
把这些分块之后的再标[0],[1]


![在这里插入图片描述](https://img-blog.csdnimg.cn/abeaef523871427fbe54cb94e831521d.png)
不断的分块，

按m个位进行分块，一共有n个bit
可以分成n/m块

## 推出公式

<u>$\frac{n}{m}$<  $2^m$</u>
有m个位为一组
一共有 $2^m$种可能

![在这里插入图片描述](https://img-blog.csdnimg.cn/e8b182fb26c146ff8ef98dd7fcbb494d.png)

内存的重新划分
![在这里插入图片描述](https://img-blog.csdnimg.cn/50dd6d71666d4f468d32230488daabbe.png)

我们上述推出的公式，m是一个合理的数字，就是为了保证每一块都能被找得到，否则块的内容无法索引全部的mm
>每一个快都指向一个位置，分块太多位置必然会重复，位置可分不完，但一定不能重复

![在这里插入图片描述](https://img-blog.csdnimg.cn/44b12af67c584a8f83abb451cca332b5.jpeg)


## 进制
m{0,1}:$2^m$种可能
每一种可能对应的<u>seq</u>，都可以和一个抽象的数字进行映射
- 十进制
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/af6b3457713642f1801cb69dec699758.png)

- 二进制
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/73528a9188874f68810c53a249caac16.png)
    二进制和十进制虽然序列seq不同，但是都能表示同样的数字
    

## 补码
![在这里插入图片描述](https://img-blog.csdnimg.cn/6d13e51974db40289df0c3a7741b6fe6.jpeg)

![在这里插入图片描述](https://img-blog.csdnimg.cn/6c214ce9dc8f4c1ab0304a61776e8cfb.jpeg)



验证溢出
~~~c
void test1()
{
    //验证溢出
    int a = 2147483647;    //最大的正数
    printf("%d\n", a + 1); //我们发现从最大的正数溢出成了最小的负数,-2147483648
    printf("%x\n", a + 1); //我们发现从最大的正数溢出成了最小的负数,0x80000000

    //验证位操作
    printf("%d\n", (~a) + 1); //取反+1，就变成该数对应的负数了-2147483637
}
~~~

# 位操作
待学习
- 树状数组


查找最小低的10序列，返回的一定是2的倍数

~~~c

unsigned LowBit(unsigned x)//这里返回的一定是2的倍数
{
    // 10101100,返回的是100
    unsigned a = x & ((~x) + 1); // x和它对应的负数，进行按位与
    //找到它最低位的1
    //只能用~ | &

    return a;
    //这个可以结合树状数组
}
~~~

